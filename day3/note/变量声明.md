# 变量声明

let 和 const是JavaScript中两种相对较新的变量声明类型。let跟var类似，但是可以避免很多陷阱。const则是常量：不允许给变量重新分配值。

TypeScript作为JavaScript的超集，天然支持let和const。

## 使用var声明变量
最简单的声明方式：

```ts
var a = 10;
```

在函数内部也可以使用：

```ts
function f() {
    var message = "Hello, World";
    return message;
}
```

甚至可以在其他函数中，访问相同的变量：

```ts
function f() {
    var a = 10;
    return function g() {
        var b = a + 1;
        return b;
    }
}

var g = f();
g(); // return 11
```

在上面的例子中，g捕获了在f中声明的变量a。当g被调用时，a的值绑定的就是在f中声明时a的值。即使在f调用结束后离职调用g，g也能够捕获或者修改a。

```ts
function f() {
    var a = 1;
    a = 2;
    var b = g();
    a = 3;
    return b;
    function g() {
        return a;
    }
}

f(); // returns 2
```

### 作用域

跟其他语言的var相比，JavaScript的var声明的变量的作用域规则很奇怪。比如下面的例子：

```ts
function f(shouldInitialize: boolean) {
    if (shouldInitialize) {
        var x = 10;
    }
    return x;
}

f(true);   // returns 10
f(false);  // returns undefined
```

是不是有些奇怪。x是声明在if块中的，但是却可以从if块外访问它。这是因为var声明的变量，可以从包含它的函数，模块，命名空间或者全局作用域访问它，而不仅仅是包含它的块。有些人称之为var -scoping或者function -scoping。参数也是function作用域。
这些作用域规则可能会引发一些奇怪的问题。一个比较常见的问题是，重复声明一个变量多次，但是却不报错。

```ts
function sumMatrix(matrix: number[][]) {
    var sum = 0;
    for (var i = 0; i< matrix.length; i++) {
        var currentRow = matrix[i];
        for (var i = 0; i< currentRow.length; i++) {
            sum += currentRow[i];
        }
    }
    return sum;
}
```

注意此处，内部的for循环中声明的变量i，会覆盖外部for循环中声明的变量i，因为在这里，两个i是在同一个函数作用域的同一个变量。

### 变量捕获的奇怪之处

猜猜看下面这段代码会输出什么？

```ts
// setTimeout 会等待指定的时间之后，再执行
for(var i = 0; i < 10; i++) {
    setTimeout(function() { conssole.log(i); }, 100 * i);
}
```

看看这段代码的实际输出和设想的输出，是不是一样：
| 实际输出 | 理想输出 |
| :-- | :-- |
| 10<br>10<br>10<br>10<br>10<br>10<br>10<br>10<br>10<br>10 | 0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9 |

还记得前面说过的变量捕获吗？我们传递给setTimeout中的每个函数表达式的i都是来自同一个作用域的同一个i。

这意味着什么呢？setTimeout会在指定时间后，执行function，此时for循环已经停止。for循环停止后，i的值是10。因此，每一次function调用，输出的都是10。

那如果要实现理想输出，应该怎样写呢？使用**IIFE**：立即调用的函数表达式，在每一次迭代中，捕获i。

```ts
for (var i = 0; i< 10; i++) {
    // 通过使用i当前的值调用函数，来捕获i的当前状态
    (function(i) {
        setTimeout(function() { conssole.log(i); }, 100 * i);
    })(i);
}
```

这种写法看起来很怪异。参数i遮蔽了for循环中声明的i，达到了理想中的输出效果。